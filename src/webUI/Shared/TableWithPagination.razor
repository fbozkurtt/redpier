@typeparam TItem
@inject HttpClient HttpClient
@inject IToastService ToastService

@if (RemoveButton)
{
    <div class="btn-group float-right">
        <button type="button" class="btn btn-sm btn-danger" @onclick="async ()=> { await Remove(); }" disabled="@(IsBusy || !SelectedItems.Any())">
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" hidden="@(!IsBusy)"></span>
            <span class="fa fa-trash" hidden="@(IsBusy)"></span> Remove
        </button>
    </div>
}
<div class="table-responsive py-2">
    <table class="table table-hover table-sm">
        <thead class="thead-light">
            <tr>
                <th><input type="checkbox" checked="@SelectedItems.Any()" @onclick="SelectAll" /></th>
                @TableHeader
            </tr>
        </thead>
        <tbody>
            @if (Page != null)
            {
                @foreach (var item in Page.Items)
                {
                    <tr>
                        <td><input type="checkbox" checked="@SelectedItems.Contains(item)" @onclick="async () => { await Select(item); }" /></td>
                        @TableRow(item)
                    </tr>
                }
            }
            else if (IsBusy && Page == null)
            {
                <tr>
                    <td colspan="4">
                        <div class="text-center dropdown-item">
                            <div class="spinner-border spinner-border-sm" role="status">
                                <span class="sr-only">Loading...</span>
                            </div>
                        </div>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>
@if (Page != null && Page.TotalPages > 1)
{
    <nav aria-label="Page navigation">
        <ul class="pagination justify-content-end">
            <li class="page-item @(Page.HasPreviousPage ? "" : "disabled")">
                <a class="page-link" tabindex="-1" @onclick="async () => await FetchNewPage(Page.PageIndex - 1)">Previous</a>
            </li>
            @for (int i = 1; i <= Page.TotalPages; i++)
            {
                var index = i;
                <li class="page-item"><a class="page-link @(index == Page.PageIndex ? "active disabled" : "")" @onclick="async () => await FetchNewPage(index)">@index</a></li>
            }
            <li class="page-item @(Page.HasNextPage ? "" : "disabled")">
                <a class="page-link" @onclick="async () => await FetchNewPage(Page.PageIndex + 1)">Next</a>
            </li>
        </ul>
    </nav>
}

@code{
    [CascadingParameter]
    public List<TItem> SelectedItems { get; set; }

    [Parameter]
    public int PageSize { get; set; } = 10;

    [Parameter]
    public string ControllerName { get; set; } = typeof(TItem).Name;

    [Parameter]
    public RenderFragment TableHeader { get; set; }

    [Parameter]
    public RenderFragment<TItem> TableRow { get; set; }

    [Parameter]
    public bool RemoveButton { get; set; } = true;

    [Parameter]
    public EventCallback<List<TItem>> OnItemSelected { get; set; }

    public PaginatedListDto<TItem> Page { get; set; }

    public bool IsBusy { get; set; } = true;


    protected override async Task OnInitializedAsync()
    {
        await FetchNewPage(1);
    }

    public async Task FetchNewPage(int pageNumber)
    {
        try
        {
            IsBusy = true;
            var response = await HttpClient.GetAsync($"/api/{ControllerName}?pagesize={PageSize}&pagenumber={pageNumber}");

            if (response.IsSuccessStatusCode)
            {
                Page = await response.Content.ReadFromJsonAsync<PaginatedListDto<TItem>>();
            }
        }
        catch (AccessTokenNotAvailableException ex)
        {
            ex.Redirect();
        }
        catch (Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
        finally
        {
            await OnItemSelected.InvokeAsync(new List<TItem>());
            IsBusy = false;
        }
    }

    public async Task Remove()
    {
        IsBusy = true;
        try
        {
            var responses = new List<HttpResponseMessage>();
            var removedItems = new List<TItem>();
            foreach (var item in SelectedItems)
            {
                var response = await HttpClient.DeleteAsync($"/api/{ControllerName}?Id={(item as DockerEndpointDto).Id}");
                responses.Add(response);
                if (response.IsSuccessStatusCode)
                    removedItems.Add(item);
            }
            if (responses.Any(r => r.IsSuccessStatusCode))
            {
                Page.Items.RemoveAll(i => SelectedItems.Contains(i));
                foreach (var item in removedItems)
                {
                    SelectedItems.Remove(item);
                }
                ToastService.ShowSuccess($"Removed {responses.Where(r => r.IsSuccessStatusCode).Count()} {"item"/*GetDisplayName<TItem>() ?? typeof(TItem).Name*/}(s).");
            }
            if (responses.Any(r => !r.IsSuccessStatusCode))
                ToastService.ShowError($"Failed when removing {responses.Where(r => !r.IsSuccessStatusCode).Count()} {"item"/*GetDisplayName<TItem>() ?? typeof(TItem).Name*/}(s).");

        }
        catch (AccessTokenNotAvailableException ex)
        {
            ex.Redirect();
        }
        catch (Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
        finally
        {
            await OnItemSelected.InvokeAsync(SelectedItems);
            IsBusy = false;
        }
    }

    public async Task SelectAll()
    {
        if (SelectedItems.Any())
            await OnItemSelected.InvokeAsync(new List<TItem>());
        else
            await OnItemSelected.InvokeAsync(Page.Items.ToList());
    }

    public async Task Select(TItem item)
    {
        if (SelectedItems.Contains(item))
        {
            SelectedItems.Remove(item);
            await OnItemSelected.InvokeAsync(SelectedItems);
        }
        else
        {
            SelectedItems.Add(item);
            await OnItemSelected.InvokeAsync(SelectedItems);
        }
    }

    //public static string GetDisplayName<T>()
    //{
    //    return (typeof(T)
    //        .GetCustomAttributes(typeof(DisplayNameAttribute), true)
    //        .FirstOrDefault() as DisplayNameAttribute)?.DisplayName;
    //}
}